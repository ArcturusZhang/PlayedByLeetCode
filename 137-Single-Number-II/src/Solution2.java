public class Solution2 extends Solution {
    /**
     * 利用位运算。
     * 一个数字最多出现三次，所以需要构造3个状态，这样需要两个位，记作a和b。利用这两个位统计整个数组中的每个数字在每一位上的数字1出现的此数
     *  (a, b) | c | 结果(a, b)
     *  (0, 0) | 0 | (0, 0)
     *  (0, 1) | 0 | (0, 1)
     *  (1, 0) | 0 | (1, 0)
     *  (0, 0) | 1 | (0, 1)
     *  (0, 1) | 1 | (1, 0)
     *  (1, 0) | 1 | (0, 0)
     * 当遇到0时，状态不变（无视所有0）。当遇到1时，转换到下一状态，出现第三次时归零。
     * 最后返回的结果应当根据a和b的状态决定，(0, 0)表示这一位的1出现了0次或者3次，应返回0。(0, 1)和(1, 0)表示这一位的1出现了1次或者2次
     * 由于本题没有数字恰好出现2次，所以只有(0, 1)是可能的结果。但无论如何返回a | b即可。
     * 最后只需要使用位运算实现上面的运算规则即可。
     * 从结果来讲是（不知如何构造的）：
     * a = (a & ~b & ~c) | (~a & b & c);
     * b = (~a & ~b & c) | (~a & b & ~c);
     * 时间复杂度：O(n)
     * 空间复杂度：O(n)
     * @param nums
     * @return
     */
    @Override
    public int singleNumber(int... nums) {
        int a = 0, b = 0;
        for (int c : nums) {
            int tmp = (a & ~b & ~c) | (~a & b & c);
            b = (~a & ~b & c) | (~a & b & ~c);
            a = tmp;
        }
        return a | b;
    }
}
